# 理解方法调用

假设要调用x.f\(param\)，隐式参数x声明为类C的一个对象。下面是调用过程的详细描述：



1. 编译器查看对象的声明类型和方法名。假设调用x.f\(param\)，且隐式参数x声明为C类的对象。需要注意的是：有可能存在多个名字为f，但参数类型不一样的方法。例如，可能存在方法f\(int\)和方法f\(String\)。编译器将会列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法\(超类的私有方法不可访问\)。至此，编译器已获得所有可能被调用的候选方法。
2. 接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为重载解析\(overloading resolution\)。由于允许类型转换，所以这个过程可能会很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。至此，编译器已获得需要调用的方法名字和参数。
   1. 方法的名字和参数列表称为方法的签名。如果在子类中定义了一个与超类签名相同的方法，那么子类中的这个方法就覆盖了超类中的这个相同签名的方法。
   2. 返回类型不是签名的一部分，因此，在覆盖方法时，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型。
3. 如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为静态绑定（static binding）。与此对应的是，调用方法依赖于隐式参数的实际类型，并且在运行时动态绑定。如x.f\(param\)。
4. 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。假设x的实际类型是D，它是C类的子类。如果D类定义了一个方法f\(String\)，就直接调用它；否则，将在D类的超类中寻找f\(String\)，以此类推。
   1. 每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方法表（method table），其中列出了所有方法的签名和实际调用的方法。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就可以了。如果调用了super.f\(param\)，编译器将对隐式参数超类的方法表进行搜索。

